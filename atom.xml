<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端技術紀錄</title>
  
  <subtitle>紀錄前端技術以及筆記的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://s95050937.github.io/"/>
  <updated>2020-08-02T07:51:41.538Z</updated>
  <id>https://s95050937.github.io/</id>
  
  <author>
    <name>wuuu4280</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS之變量如何賦值</title>
    <link href="https://s95050937.github.io/2020/08/02/JS-post03/"/>
    <id>https://s95050937.github.io/2020/08/02/JS-post03/</id>
    <published>2020-08-02T07:48:25.000Z</published>
    <updated>2020-08-02T07:51:41.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS之變量如何賦值"><a href="#JS之變量如何賦值" class="headerlink" title="JS之變量如何賦值"></a>JS之變量如何賦值</h1><h2 id="變量有甚麼類型"><a href="#變量有甚麼類型" class="headerlink" title="變量有甚麼類型"></a>變量有甚麼類型</h2><ol><li><p>基本類型</p><blockquote><p>Undefine，String，Boolean，Null，Number</p></blockquote></li><li><p>引用類型</p><blockquote><p>Object包括它的延伸</p></blockquote></li></ol><h2 id="探討的問題"><a href="#探討的問題" class="headerlink" title="探討的問題"></a>探討的問題</h2><blockquote><p>當我們給變量賦值另一個變量，會發生發生甚麼</p></blockquote><p>注意: </p><p>​    在JS裡面，一個變量的值絕對不會指向另一個變量，而是指向內存</p><a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="情況一-基本類型"><a href="#情況一-基本類型" class="headerlink" title="情況一: 基本類型"></a>情況一: 基本類型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> num2 = num1</span><br></pre></td></tr></table></figure><p>我們用num1這個變量初始化了num2，技術上來說會指向同一個內存地址</p><p><img src="/images/JS03/1.png" alt=""></p><p>如果今天對num2 進行操作，num1會因此改變嗎? </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> num2 = num1</span><br><span class="line">num2 + <span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p>答案是不會的，因為基本類型是不可變的，所以num2會自行指向自身的內存地址</p><p><img src="/images/JS03/2.png" alt=""></p><p>這時候可以打印看看num1是否真的不會變</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> num2 = num1</span><br><span class="line">num2 + <span class="string">'bar'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'num1:'</span>,num1)</span><br></pre></td></tr></table></figure><p>結果: </p><p><img src="/images/JS03/3.png" alt=""></p><h3 id="情況二-引用類型"><a href="#情況二-引用類型" class="headerlink" title="情況二: 引用類型"></a>情況二: 引用類型</h3><h4 id="預先知識"><a href="#預先知識" class="headerlink" title="預先知識"></a>預先知識</h4><p>引用類型賦值時的情況比較特別，會先引用到stack的某一個地址，再透過那個地址的值(heap的地址)查找到heap的值，比方說下面這樣</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></span><br><span class="line">obj1.bar = <span class="number">2</span> <span class="comment">// 為了證明那兩個是不同(相同的話obj2會被obj1影響)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>示意圖: </p><p><img src="/images/JS03/4.png" alt=""></p><h4 id="正題"><a href="#正題" class="headerlink" title="正題"></a>正題</h4><p>假如把一個變量用另一個變量賦值會怎麼樣?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1 <span class="comment">// 把obj1的內存地址給了他</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// 這個就變成true</span></span><br><span class="line">obj1.bar = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// 這個也會受到obj1的操作影響</span></span><br></pre></td></tr></table></figure><h4 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h4><p><img src="/images/JS03/5.png" alt=""></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>上面之所以沒變，是因為我們都是對heap進行操作，所以obj2當然會被影響，假設我對下面對象這樣操作結果就會不一樣!!!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1 <span class="comment">// 內存複製</span></span><br><span class="line"></span><br><span class="line">obj1.bar = <span class="number">2</span> <span class="comment">// 將heap內的值改變(因為obj2指向的stack部變所以也會受到影響)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 這裡非常關鍵，obj2在stack裡指向的地址發生改變，所以之後假設對這個對象操作，已經不是obj1指向的那個對象，obj1理所當然不會改變</span></span><br><span class="line">obj2 = &#123;  </span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj2.baz = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;foo: 1, bar: 2&#125; 沒有baz!!</span></span><br></pre></td></tr></table></figure><h4 id="示意圖-1"><a href="#示意圖-1" class="headerlink" title="示意圖"></a>示意圖</h4><ol><li><p>內存賦值完成(  let obj2 = obj1  )</p><p><img src="/images/JS03/6.png" alt=""></p></li><li><p>將heap內的值改變(  obj1.bar = 2  )</p><p><img src="/images/JS03/7.png" alt=""></p></li><li><p>obj2被賦予新的值(  obj2= {foo: 1,bar: 2}  )</p><p><img src="/images/JS03/8.png" alt=""></p></li><li><p>操作obj2對應的對象(  obj2.baz = 3  )</p><p><img src="/images/JS03/9.png" alt=""></p></li><li><p>結論</p><p>所以最後打印obj1的時候跑出來的是{foo:1, bar: 2} !!!!!</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS之變量如何賦值&quot;&gt;&lt;a href=&quot;#JS之變量如何賦值&quot; class=&quot;headerlink&quot; title=&quot;JS之變量如何賦值&quot;&gt;&lt;/a&gt;JS之變量如何賦值&lt;/h1&gt;&lt;h2 id=&quot;變量有甚麼類型&quot;&gt;&lt;a href=&quot;#變量有甚麼類型&quot; class=&quot;headerlink&quot; title=&quot;變量有甚麼類型&quot;&gt;&lt;/a&gt;變量有甚麼類型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本類型&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Undefine，String，Boolean，Null，Number&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引用類型&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object包括它的延伸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;探討的問題&quot;&gt;&lt;a href=&quot;#探討的問題&quot; class=&quot;headerlink&quot; title=&quot;探討的問題&quot;&gt;&lt;/a&gt;探討的問題&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;當我們給變量賦值另一個變量，會發生發生甚麼&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意: &lt;/p&gt;
&lt;p&gt;​    在JS裡面，一個變量的值絕對不會指向另一個變量，而是指向內存&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP緩存</title>
    <link href="https://s95050937.github.io/2020/07/30/HTTP-post06/"/>
    <id>https://s95050937.github.io/2020/07/30/HTTP-post06/</id>
    <published>2020-07-30T12:48:18.000Z</published>
    <updated>2020-07-30T12:53:55.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP緩存"><a href="#HTTP緩存" class="headerlink" title="HTTP緩存"></a>HTTP緩存</h1><ol><li><p>原因: </p><blockquote><p>頻繁請求非常類費流量，且一直刷新使用者體驗相當不佳</p></blockquote></li><li><p>緩存內容</p><blockquote><p>主要是一些靜態資源(比如CSS，JS)</p></blockquote></li></ol><h2 id="HTTP緩存頭部-後面會詳談"><a href="#HTTP緩存頭部-後面會詳談" class="headerlink" title="HTTP緩存頭部(後面會詳談)"></a>HTTP緩存頭部(後面會詳談)</h2><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>請求/響應頭，緩存控制<br><img src="/images/HTTP06/1.png" alt=""></p><a id="more"></a><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>表資源過期時間，與max-age共存情況下優先級較低</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>資源最新修改時間，由服務器響應給瀏覽器</p><h3 id="if-Modified-Since"><a href="#if-Modified-Since" class="headerlink" title="if-Modified-Since"></a>if-Modified-Since</h3><p>與Last-Modified一組，瀏覽器請求服務器協帶，服務器會比對這個確認版本是否更新</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p>資源標籤，服務器響應給瀏覽器</p><h3 id="if-None-Match"><a href="#if-None-Match" class="headerlink" title="if-None-Match"></a>if-None-Match</h3><p>與Etag一組，瀏覽器請求服務器協帶，服務器會比對這個確認版本是否更新</p><h2 id="HTTP-緩存工作方式"><a href="#HTTP-緩存工作方式" class="headerlink" title="HTTP 緩存工作方式"></a>HTTP 緩存工作方式</h2><p>現在開始假設服務器在跟瀏覽器對話</p><h2 id="情境一-服務器與瀏覽器約定一個文件過期時間-Expires"><a href="#情境一-服務器與瀏覽器約定一個文件過期時間-Expires" class="headerlink" title="情境一 服務器與瀏覽器約定一個文件過期時間(Expires)"></a>情境一 服務器與瀏覽器約定一個文件過期時間(Expires)</h2><ul><li><p>瀏覽器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ㄟㄟ，服務器，你的文件找一下有沒有一個叫做main.js的文件，找到後再給我</span><br></pre></td></tr></table></figure></li><li><p>服務器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OKOK，可是我怕你跟一直跟我要，所以給你一個Expires，等過了這個時間你再跟我要吧!</span><br></pre></td></tr></table></figure></li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><blockquote><p>Expires(透過響應頭)主要是約定一個過期時間，在過期時間前客戶端不會向服務器要資源</p></blockquote><h3 id="延伸情況二"><a href="#延伸情況二" class="headerlink" title="延伸情況二"></a>延伸情況二</h3><blockquote><p>上面情況，假如文件過期後，該文件在服務器端沒有更新，就代表客戶端請求道的文件不就一模一樣，因此出了情境二</p></blockquote><h2 id="情境二-在Expires基礎上再加上Last-Modified以及if-Modified-Since"><a href="#情境二-在Expires基礎上再加上Last-Modified以及if-Modified-Since" class="headerlink" title="情境二 在Expires基礎上再加上Last-Modified以及if-Modified-Since"></a>情境二 在Expires基礎上再加上Last-Modified以及if-Modified-Since</h2><ul><li><p>瀏覽器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ㄟㄟ，服務器，你的文件找一下有沒有一個叫做main.js的文件，找到後再給我</span><br></pre></td></tr></table></figure></li><li><p>服務器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OKOK，可是我怕你跟一直跟我要，所以給你一個Expires，等過了這個時間你再跟我要吧! 啊還有我怕到時候文件沒更新你又要我找給你，所以我回傳一個Last-Modified喔</span><br></pre></td></tr></table></figure></li><li><p>瀏覽器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好，那等文件過期後我再回傳if-Modified-Since給你喔，方便你核對版本</span><br></pre></td></tr></table></figure></li></ul><h3 id="總結-1"><a href="#總結-1" class="headerlink" title="總結:"></a>總結:</h3><p>if-Modified-Since與Last-Modified回傳樣子是</p><p><img src="/images/HTTP06/2.png" alt=""></p><blockquote><ol><li>如果Expires還沒過期，則瀏覽器聰明的使用緩存</li><li>過期了之後，瀏覽器請求時附上if-Modified-Since， 假如文件在服務器端有更新，服務器回傳304 Not Modified</li></ol></blockquote><h3 id="延伸情況三"><a href="#延伸情況三" class="headerlink" title="延伸情況三"></a>延伸情況三</h3><blockquote><p>情況二可以發現，if-Modified-Since與Last-Modified這兩個最小單位是秒，如果今天更新的時間與那兩個相差不到1秒文件就不會更新。假如今天我服務器的平台過大，比方說FB，總是會有這個情況發生</p></blockquote><h2 id="情況三-在情況二的基礎上，增加一個文件內容唯一標示Etag與if-None-Match-然後在加入max-age"><a href="#情況三-在情況二的基礎上，增加一個文件內容唯一標示Etag與if-None-Match-然後在加入max-age" class="headerlink" title="情況三 在情況二的基礎上，增加一個文件內容唯一標示Etag與if-None-Match, 然後在加入max-age"></a>情況三 在情況二的基礎上，增加一個文件內容唯一標示Etag與if-None-Match, 然後在加入max-age</h2><ol><li>max-age優先度比Expires高，因此這裡expires會被取代，單位是秒，表幾秒後緩存過期</li><li>Etag與if-None_Match的關係就像是Last-Modified以及if-Modified-Since</li><li>所以在這個情況Expires與Last-Modified其實沒啥用</li></ol><ul><li><p>瀏覽器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ㄟㄟ，服務器，你的文件找一下有沒有一個叫做main.js的文件，找到後再給我</span><br></pre></td></tr></table></figure></li><li><p>服務器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OKOK，可是我怕你跟一直跟我要，所以給你一個Expires，等過了這個時間你再跟我要吧! 啊還有我怕到時候文件沒更新你又要我找給你，所以我回傳一個Last-Modified喔，但好像不夠精準，算了我再傳一個Etag以及max-age給你好了</span><br></pre></td></tr></table></figure></li><li><p>瀏覽器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好，既然有更精準的Etag以及max-age那我當然看這個囉，那我之後再回傳if-None-Match給你做核對版本</span><br></pre></td></tr></table></figure></li></ul><h3 id="總結-2"><a href="#總結-2" class="headerlink" title="總結:"></a>總結:</h3><blockquote><p>到這裡瀏覽器已經可以精準確定緩存時間以及緩存文件是否相同</p></blockquote><h2 id="CDN緩存"><a href="#CDN緩存" class="headerlink" title="CDN緩存"></a>CDN緩存</h2><p>CDN自己也有緩存，並將緩存的靜態資源傳給瀏覽器，跟瀏覽器的行為也很像</p><ul><li><p>瀏覽器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ㄟㄟ，服務器，你的文件找一下有沒有一個叫做main.js的文件，找到後再給我</span><br></pre></td></tr></table></figure></li><li><p>服務器: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">別找我，找我老弟CDN吧</span><br></pre></td></tr></table></figure></li></ul><h2 id="瀏覽器對緩存的影響"><a href="#瀏覽器對緩存的影響" class="headerlink" title="瀏覽器對緩存的影響"></a>瀏覽器對緩存的影響</h2><p><img src="/images/HTTP06/3.png" alt=""></p><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP緩存&quot;&gt;&lt;a href=&quot;#HTTP緩存&quot; class=&quot;headerlink&quot; title=&quot;HTTP緩存&quot;&gt;&lt;/a&gt;HTTP緩存&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;原因: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頻繁請求非常類費流量，且一直刷新使用者體驗相當不佳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;緩存內容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是一些靜態資源(比如CSS，JS)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;HTTP緩存頭部-後面會詳談&quot;&gt;&lt;a href=&quot;#HTTP緩存頭部-後面會詳談&quot; class=&quot;headerlink&quot; title=&quot;HTTP緩存頭部(後面會詳談)&quot;&gt;&lt;/a&gt;HTTP緩存頭部(後面會詳談)&lt;/h2&gt;&lt;h3 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h3&gt;&lt;p&gt;請求/響應頭，緩存控制&lt;br&gt;&lt;img src=&quot;/images/HTTP06/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP代理</title>
    <link href="https://s95050937.github.io/2020/07/30/HTTP-post05/"/>
    <id>https://s95050937.github.io/2020/07/30/HTTP-post05/</id>
    <published>2020-07-30T10:51:45.000Z</published>
    <updated>2020-07-30T10:54:46.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h1><p>像是中間人的概念，對待裡來說既可以當服務端也可以當客戶端</p><h2 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h2><p><img src="/images/HTTP05/1.png" alt=""></p><a id="more"></a><h2 id="為何需要代理"><a href="#為何需要代理" class="headerlink" title="為何需要代理"></a>為何需要代理</h2><h3 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1. 抓包"></a>1. 抓包</h3><p>能更好分析請求與安全測試</p><h3 id="2-FQ"><a href="#2-FQ" class="headerlink" title="2. FQ"></a>2. FQ</h3><p>俗稱的翻牆</p><p><img src="/images/HTTP05/2.png" alt=""></p><h3 id="3-匿名訪問"><a href="#3-匿名訪問" class="headerlink" title="3. 匿名訪問"></a>3. 匿名訪問</h3><p>刪除客戶端HTTP報文中的私人資料，比方說Cookie或是IP地址，</p><h3 id="4-過濾器"><a href="#4-過濾器" class="headerlink" title="4. 過濾器"></a>4. 過濾器</h3><p>比方說不希望孩童從網路上看到非該年齡層的內容，因此可以透過代理過慮服務端回傳的內容</p><p><img src="/images/HTTP05/3.png" alt=""></p><h2 id="補充-網關"><a href="#補充-網關" class="headerlink" title="補充(網關)"></a>補充(網關)</h2><p>又稱作協議轉換器，為資源與應用程序的黏合器</p><h3 id="示意圖-1"><a href="#示意圖-1" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP05/4.png" alt=""></p><h3 id="講解"><a href="#講解" class="headerlink" title="講解"></a>講解</h3><p>從上圖可以發現和代理很類似，最關鍵的一點就是我們可以透過網關轉換協議，比方說上圖客戶端向網關發起HTTP協議，而後經過網觀象服務器端發起POP。</p><h3 id="分類"><a href="#分類" class="headerlink" title="分類"></a>分類</h3><p>Web在一端使用HTTP，另一端採用另一種協議可以這樣標示</p><ol><li><p>(/HTTP) 客戶端網關: 與客戶端採用其他協議，與服務端採用HTTP</p><p>記憶點: 叫客戶端網關可想像成他是幫客戶端轉換成HTTP協議的方式</p></li><li><p>(HTTP/) 服務端網關: 與服務端端採用其他協議，與客戶端採用HTTP</p><p>記憶點: 與客戶端相反</p></li></ol><h3 id="常見網關"><a href="#常見網關" class="headerlink" title="常見網關"></a>常見網關</h3><ol><li><p>(HTTP/ *) 服務器端Web網關</p></li><li><p>(HTTP/HTTPS) 服務器端安全網關</p><p> (將客戶端傳來的HTTP協議加密成HTTPS)</p></li><li><p>(HTTPS/HTTP) 客戶端安全網關 </p></li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-代理&quot;&gt;&lt;a href=&quot;#HTTP-代理&quot; class=&quot;headerlink&quot; title=&quot;HTTP 代理&quot;&gt;&lt;/a&gt;HTTP 代理&lt;/h1&gt;&lt;p&gt;像是中間人的概念，對待裡來說既可以當服務端也可以當客戶端&lt;/p&gt;
&lt;h2 id=&quot;示意圖&quot;&gt;&lt;a href=&quot;#示意圖&quot; class=&quot;headerlink&quot; title=&quot;示意圖&quot;&gt;&lt;/a&gt;示意圖&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/HTTP05/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JS靜態與動態作用域</title>
    <link href="https://s95050937.github.io/2020/07/29/JS-post02/"/>
    <id>https://s95050937.github.io/2020/07/29/JS-post02/</id>
    <published>2020-07-29T14:27:49.000Z</published>
    <updated>2020-07-29T14:30:49.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS靜態與動態作用域"><a href="#JS靜態與動態作用域" class="headerlink" title="JS靜態與動態作用域"></a>JS靜態與動態作用域</h2><p>JavaScript使用的是靜態作用域，非動態這件事要先提前知道</p><h3 id="靜態作用域"><a href="#靜態作用域" class="headerlink" title="靜態作用域"></a>靜態作用域</h3><ol><li><p>懶人包 : </p><blockquote><p>會主動去尋找函數與變量定義時的狀況</p></blockquote></li><li><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'靜態作用域'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'動態作用域'</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// '靜態作用域'</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>分析 :</p><p>如果沒有作用域鏈的概念可以參考下面思維</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 前面都很正常的順順執行下來直到bar()</span><br><span class="line"><span class="number">2.</span> 當執行bar時候，會從全局作用域(因為bar執行的地方在全局作用域)裡面尋找bar聲明的地方</span><br><span class="line"><span class="number">3.</span> 進到bar函數作用域裡面(壓棧) <span class="comment">// 所在第六行</span></span><br><span class="line"><span class="number">4.</span> 在bar函數作用域裡面執行foo()，但在該函數作用域裡面沒有聲明foo，因此跑到上一層尋找，就是全局作用域</span><br><span class="line"><span class="number">5.</span> 找到foo聲明的地方，並進入foo作用域裡面</span><br><span class="line"><span class="number">5.</span> 試圖打印出a <span class="comment">// 此時所在是第四行</span></span><br><span class="line"><span class="number">6.</span> 因為foo作用域裡面沒有聲明變量a，因此又跑到全局作用域</span><br><span class="line"><span class="number">7.</span> 找到a(靜態作用域)並打印出來</span><br></pre></td></tr></table></figure></li></ol><h3 id="動態作用域"><a href="#動態作用域" class="headerlink" title="動態作用域"></a>動態作用域</h3><ol><li><p>懶人包: </p><blockquote><p>會到執行時的環境尋找</p></blockquote></li><li><p>例子(跟靜態相同): </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'靜態作用域'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'動態作用域'</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// '動態作用域'</span></span><br></pre></td></tr></table></figure><p>分析: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">前面五點都一模一樣直到第六點</span><br><span class="line"><span class="number">1.</span> 前面都很正常的順順執行下來直到bar()</span><br><span class="line"><span class="number">2.</span> 當執行bar時候，會從全局作用域(因為bar執行的地方在全局作用域)裡面尋找bar聲明的地方</span><br><span class="line"><span class="number">3.</span> 進到bar函數作用域裡面(壓棧) <span class="comment">// 所在第六行</span></span><br><span class="line"><span class="number">4.</span> 在bar函數作用域裡面執行foo()，但在該函數作用域裡面沒有聲明foo，因此跑到上一層尋找，就是全局作用域</span><br><span class="line"><span class="number">5.</span> 找到foo聲明的地方，並進入foo作用域裡面</span><br><span class="line"><span class="number">5.</span> 試圖打印出a </span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 這時候找不到a並不會跑到上一層作用域鏈查找，而是回到執行時的環境也就是第八行所在的作用域查找</span><br><span class="line"><span class="number">7.</span> 這時候就會發現a是動態作用域並打印出</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS靜態與動態作用域&quot;&gt;&lt;a href=&quot;#JS靜態與動態作用域&quot; class=&quot;headerlink&quot; title=&quot;JS靜態與動態作用域&quot;&gt;&lt;/a&gt;JS靜態與動態作用域&lt;/h2&gt;&lt;p&gt;JavaScript使用的是靜態作用域，非動態這件事要先提前知道&lt;/p&gt;
&lt;h3 id=&quot;靜態作用域&quot;&gt;&lt;a href=&quot;#靜態作用域&quot; class=&quot;headerlink&quot; title=&quot;靜態作用域&quot;&gt;&lt;/a&gt;靜態作用域&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;懶人包 : &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;會主動去尋找函數與變量定義時的狀況&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例子:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;靜態作用域&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;動態作用域&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  foo()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar() &lt;span class=&quot;comment&quot;&gt;// &#39;靜態作用域&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP的長連接與短連接</title>
    <link href="https://s95050937.github.io/2020/07/29/HTTP-post04/"/>
    <id>https://s95050937.github.io/2020/07/29/HTTP-post04/</id>
    <published>2020-07-29T11:47:18.000Z</published>
    <updated>2020-07-29T11:49:46.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP的長連接與短連接"><a href="#HTTP的長連接與短連接" class="headerlink" title="HTTP的長連接與短連接"></a>HTTP的長連接與短連接</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>其實HTTP的長連接與短連接是在講TCP的長連接與短連接</p></blockquote><h2 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h2><p>打開台大的網站按F12，可以發現有一個Connection: Keep-Alive，那個就是長連結</p><p><img src="/images/HTTP04/1.png" alt=""></p><a id="more"></a><h2 id="差別"><a href="#差別" class="headerlink" title="差別"></a>差別</h2><p>短連接 </p><blockquote><p>建立連結 =&gt; 數據傳輸 =&gt; 關閉連結 =&gt; ….  =&gt; 建立連結 =&gt; 數據傳輸 =&gt; 關閉連結 =&gt;</p></blockquote><p>長連結(可以省去TCP連接與關閉的時間)</p><p>​    通常關閉連結會是服務端，因為隨著連結的客戶端越來越多，服務端會有撐不下去的時候</p><blockquote><p>建立連結 =&gt; 數據傳輸 =&gt; …. (保持連結) …. =&gt;  數據傳輸 =&gt; 關閉連結</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>具體誰好誰壞沒有一定，當然還是要視情況而定</p><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP的長連接與短連接&quot;&gt;&lt;a href=&quot;#HTTP的長連接與短連接&quot; class=&quot;headerlink&quot; title=&quot;HTTP的長連接與短連接&quot;&gt;&lt;/a&gt;HTTP的長連接與短連接&lt;/h1&gt;&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其實HTTP的長連接與短連接是在講TCP的長連接與短連接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;實際案例&quot;&gt;&lt;a href=&quot;#實際案例&quot; class=&quot;headerlink&quot; title=&quot;實際案例&quot;&gt;&lt;/a&gt;實際案例&lt;/h2&gt;&lt;p&gt;打開台大的網站按F12，可以發現有一個Connection: Keep-Alive，那個就是長連結&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/HTTP04/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之身分認證</title>
    <link href="https://s95050937.github.io/2020/07/29/HTTP-post03/"/>
    <id>https://s95050937.github.io/2020/07/29/HTTP-post03/</id>
    <published>2020-07-29T11:16:19.000Z</published>
    <updated>2020-07-29T11:20:08.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP之身分認證"><a href="#HTTP之身分認證" class="headerlink" title="HTTP之身分認證"></a>HTTP之身分認證</h1><p>有以下四種認證</p><ol><li>BASIC認證 (基本認證)</li><li>DIGEST認證 (摘要認證)</li><li>SSL客戶端認證</li><li>FormBase認證 (基於表單驗證)</li></ol><a id="more"></a><h2 id="BASIC認證"><a href="#BASIC認證" class="headerlink" title="BASIC認證"></a>BASIC認證</h2><p>HTTP 1.0 即存在</p><h3 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP03/1.png" alt=""></p><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>因為沒有加密，如果不小心被其他有心人士獲取，則帳號密碼經Base64解碼即獲得相當不安全，因此又有了DIGEST認證</p><h2 id="DIGEST-認證"><a href="#DIGEST-認證" class="headerlink" title="DIGEST 認證"></a>DIGEST 認證</h2><p>HTTP1.1存在</p><h3 id="示意圖-1"><a href="#示意圖-1" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP03/2.png" alt=""></p><p>這種方法雖然解決加密，但沒有解決用戶可能被冒充的問題(只要用戶名與密碼正確就認為你是本人)</p><h2 id="SSL-客戶端認證"><a href="#SSL-客戶端認證" class="headerlink" title="SSL 客戶端認證"></a>SSL 客戶端認證</h2><p>藉由HTTPS 客戶端憑證，服務器可確認訪問是否來自已登入瘩客戶端</p><h2 id="基於表單驗證明"><a href="#基於表單驗證明" class="headerlink" title="基於表單驗證明"></a>基於表單驗證明</h2><ol><li>不是在HTTP協議定義的</li><li>使用web各自實現表單認證方式</li><li>通過cookie與session</li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP之身分認證&quot;&gt;&lt;a href=&quot;#HTTP之身分認證&quot; class=&quot;headerlink&quot; title=&quot;HTTP之身分認證&quot;&gt;&lt;/a&gt;HTTP之身分認證&lt;/h1&gt;&lt;p&gt;有以下四種認證&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BASIC認證 (基本認證)&lt;/li&gt;
&lt;li&gt;DIGEST認證 (摘要認證)&lt;/li&gt;
&lt;li&gt;SSL客戶端認證&lt;/li&gt;
&lt;li&gt;FormBase認證 (基於表單驗證)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP協議編碼與解碼</title>
    <link href="https://s95050937.github.io/2020/07/29/HTTP-post02/"/>
    <id>https://s95050937.github.io/2020/07/29/HTTP-post02/</id>
    <published>2020-07-29T10:44:53.000Z</published>
    <updated>2020-07-29T10:49:02.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP協議編碼與解碼"><a href="#HTTP協議編碼與解碼" class="headerlink" title="HTTP協議編碼與解碼"></a>HTTP協議編碼與解碼</h1><p>在講解編碼之前我們率先了解一下甚麼是碼</p><h2 id="字符集與編碼"><a href="#字符集與編碼" class="headerlink" title="字符集與編碼"></a>字符集與編碼</h2><h3 id="計算機如何顯示文字"><a href="#計算機如何顯示文字" class="headerlink" title="計算機如何顯示文字"></a>計算機如何顯示文字</h3><p>有些人應該已經知道計算機系統是利用二進制保存操作，那我們就要思考如何把這種二進制系統轉換成我們的畫面</p><h3 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP02/1.png" alt=""></p><a id="more"></a><p>現在想像計算機是一個人，如果我們今天想要找水壺的英文，那我們是不是會打開字典開始尋找。對計算機來說字符集就是他看得懂的語言，而字庫表就是他查找水壺這個英文的字典</p><ol><li>字符集: 某一個電腦看得懂的二進制代碼(地址的集合)</li><li>字庫表: 儲存所有二進制代碼的具體內容(那一本字典)</li><li>編碼方式: 算法，因為二進制樹又臭又長很難搞</li></ol><h3 id="具體流程"><a href="#具體流程" class="headerlink" title="具體流程"></a>具體流程</h3><blockquote><p>一個二進制樹經過一個編碼方式得到字符集對應的地址，在字庫表找到對應的字符，最後顯示給用戶</p></blockquote><h2 id="常見編碼規範"><a href="#常見編碼規範" class="headerlink" title="常見編碼規範"></a>常見編碼規範</h2><p><img src="/images/HTTP02/2.png" alt=""></p><h2 id="為何會亂碼"><a href="#為何會亂碼" class="headerlink" title="為何會亂碼"></a>為何會亂碼</h2><p>不管是在編碼或者解碼的過程中，假如我們解析的過程沒有找到一一對應的字符集或者字符表，就會產生亂碼。比方說ASCII不支持中文，如果我們在解碼過程發現中文字就會產生亂碼。</p><h2 id="URL的編碼以及解碼"><a href="#URL的編碼以及解碼" class="headerlink" title="URL的編碼以及解碼"></a>URL的編碼以及解碼</h2><ol><li><p>採用ASCII字符集進行編碼，假如有非ASCII的字符要對其進行編碼</p></li><li><p>URL 有一些保留字(比如&amp;)，如果要在URL使用也要進行編碼</p></li></ol><h3 id="百分號編碼規範"><a href="#百分號編碼規範" class="headerlink" title="百分號編碼規範"></a>百分號編碼規範</h3><ol><li>屬於ASCII字符集的非保留字不做編碼</li><li>屬於ASCII字符集的保留字取得ASCII的內碼，再加上%前綴後進行編碼</li><li>非ASCII則取Unicode內碼，加上%前綴後進行編碼</li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP協議編碼與解碼&quot;&gt;&lt;a href=&quot;#HTTP協議編碼與解碼&quot; class=&quot;headerlink&quot; title=&quot;HTTP協議編碼與解碼&quot;&gt;&lt;/a&gt;HTTP協議編碼與解碼&lt;/h1&gt;&lt;p&gt;在講解編碼之前我們率先了解一下甚麼是碼&lt;/p&gt;
&lt;h2 id=&quot;字符集與編碼&quot;&gt;&lt;a href=&quot;#字符集與編碼&quot; class=&quot;headerlink&quot; title=&quot;字符集與編碼&quot;&gt;&lt;/a&gt;字符集與編碼&lt;/h2&gt;&lt;h3 id=&quot;計算機如何顯示文字&quot;&gt;&lt;a href=&quot;#計算機如何顯示文字&quot; class=&quot;headerlink&quot; title=&quot;計算機如何顯示文字&quot;&gt;&lt;/a&gt;計算機如何顯示文字&lt;/h3&gt;&lt;p&gt;有些人應該已經知道計算機系統是利用二進制保存操作，那我們就要思考如何把這種二進制系統轉換成我們的畫面&lt;/p&gt;
&lt;h3 id=&quot;示意圖&quot;&gt;&lt;a href=&quot;#示意圖&quot; class=&quot;headerlink&quot; title=&quot;示意圖&quot;&gt;&lt;/a&gt;示意圖&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/HTTP02/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP_詳解Cookie與Session</title>
    <link href="https://s95050937.github.io/2020/07/28/HTTP-post01/"/>
    <id>https://s95050937.github.io/2020/07/28/HTTP-post01/</id>
    <published>2020-07-28T15:20:15.000Z</published>
    <updated>2020-07-29T10:42:56.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-狀態管理-cookie與session"><a href="#HTTP-狀態管理-cookie與session" class="headerlink" title="HTTP 狀態管理: cookie與session"></a>HTTP 狀態管理: cookie與session</h1><p>大家先來想想一個例子，如果我今天要開一間咖啡館，然後有一個滿10點送50元飲料，我該怎麼去紀錄?</p><ol><li>集點蓋章</li><li>老闆自備簽名章</li></ol><p>一般人可能會講上面那兩點，但事實上上面那兩個方法有點問題，我們無法知道雙方會部會造假，因此得出了第三個方法，你有自己的會員蓋章，老闆也準備自己的系統紀錄，假如要兌換，就核對一下即可頒發。cookie與session就是為了解決第三個辦法的蓋章卡以及老闆的系統。</p><a id="more"></a><h2 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h2><h3 id="是甚麼"><a href="#是甚麼" class="headerlink" title="是甚麼"></a>是甚麼</h3><p>一小段文本訊息，客戶端請求服務器，服務器就頒發一個cookie給客戶端瀏覽器(蓋章卡) ， 客戶端瀏覽器就把它保留下來，假設下次再請求，瀏覽器會把cookie跟網址提交給服務器，讓服務器辨別用戶狀態。</p><h3 id="流程圖"><a href="#流程圖" class="headerlink" title="流程圖"></a>流程圖</h3><p><img src="/images/HTTP01/1.png" alt=""></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/images/HTTP01/2.png" alt=""></p><h2 id="如何獲取"><a href="#如何獲取" class="headerlink" title="如何獲取"></a>如何獲取</h2><blockquote><p>可以在瀏覽器打網址的地方輸入下面這行javascript:alert(document.cookie)</p></blockquote><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="是甚麼-1"><a href="#是甚麼-1" class="headerlink" title="是甚麼"></a>是甚麼</h3><blockquote><p>服務器端紀錄用戶訊息的機制(老闆的紀錄器)</p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/images/HTTP01/3.png" alt=""></p><h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>基本上cookie有效時間會非常非常久，而session因為視服務端，會有大量的session紀錄，可能會內存溢出，因此會有失效，又分成下面幾種</p><ol><li>自動失效: session超時</li><li>主動失效: 調用HttpSession.invalidate( ) </li><li>服務器進程被停止</li></ol><h2 id="兩者比較"><a href="#兩者比較" class="headerlink" title="兩者比較"></a>兩者比較</h2><ol><li><p>存放位置不同 (一個存在服務器，一個存在客戶端)</p></li><li><p>安全性不同 </p><p>cookie可能會被其他程式窺視，因此cookie盡量不要放帳號密碼</p></li><li><p>有效期不同 (session會自動清理，cookie基本上不會消失因為通常沒有像session有內存溢出的問題)</p></li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-狀態管理-cookie與session&quot;&gt;&lt;a href=&quot;#HTTP-狀態管理-cookie與session&quot; class=&quot;headerlink&quot; title=&quot;HTTP 狀態管理: cookie與session&quot;&gt;&lt;/a&gt;HTTP 狀態管理: cookie與session&lt;/h1&gt;&lt;p&gt;大家先來想想一個例子，如果我今天要開一間咖啡館，然後有一個滿10點送50元飲料，我該怎麼去紀錄?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集點蓋章&lt;/li&gt;
&lt;li&gt;老闆自備簽名章&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般人可能會講上面那兩點，但事實上上面那兩個方法有點問題，我們無法知道雙方會部會造假，因此得出了第三個方法，你有自己的會員蓋章，老闆也準備自己的系統紀錄，假如要兌換，就核對一下即可頒發。cookie與session就是為了解決第三個辦法的蓋章卡以及老闆的系統。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://s95050937.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript偽數組</title>
    <link href="https://s95050937.github.io/2020/07/27/JS_post01/"/>
    <id>https://s95050937.github.io/2020/07/27/JS_post01/</id>
    <published>2020-07-27T15:56:57.000Z</published>
    <updated>2020-07-29T14:28:06.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript之類數組完全攻略"><a href="#JavaScript之類數組完全攻略" class="headerlink" title="JavaScript之類數組完全攻略"></a>JavaScript之類數組完全攻略</h2><p>今天幫大家整理偽數組的概念，我們先來從題目開始分析</p><p>先來打造一個很酷的對象如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'length'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候來打印obj看會長怎樣</p><a id="more"></a><p><img src="/images/JS01/1.jpeg" alt=""></p><p>乍看之下他還只是一個平常的對象，但其實這個對象這時候已經變成一個類數組了! 我們來對他做以下操作可以更明白</p><p><img src="/images/JS01/2.jpeg" alt=""></p><p>可以發現到這時候他多了一個 3: “d” ，對象原本是不能這樣做的，但是在這邊卻可以實現，因此才對他取名叫做類數組。</p><h3 id="如何打造一個類數組對象"><a href="#如何打造一個類數組對象" class="headerlink" title="如何打造一個類數組對象:"></a>如何打造一個類數組對象:</h3><p>要打造出一個類數組有要打造出一個類數組有幾個條件</p><ol><li>他必須要是一個對象</li><li>屬性要為索引(數字)值</li><li>一定要有length存在</li><li>最好可以加push</li><li>附註: 如果想讓它變得更像數組可以加上splice，如下圖</li></ol><p><img src="/images/JS01/3.jpeg" alt=""></p><h3 id="出問題考考大家"><a href="#出問題考考大家" class="headerlink" title="出問題考考大家"></a>出問題考考大家</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"d"</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.push(<span class="string">"f"</span>)</span><br><span class="line">obj.push(<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p><img src="/images/JS01/4.jpeg" alt=""></p><p>3的 “d” 居然被 “f” 覆蓋掉了，而且多了一個4 : “g” ，我們來講解一下實現原理!!</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><ol><li>在講這個之前我們要先觀察Array.prototype.push的實現方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是push的偽代碼</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = TO_UNIT32(<span class="keyword">this</span>.length) <span class="comment">// 被push的數組長度(類數組採用的length就是這個)</span></span><br><span class="line">  <span class="keyword">var</span> m = %_AraumentsLength() <span class="comment">// push的總長度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i + n] = %_Arauments(i)  <span class="comment">// 複製給原數組</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">this</span>.length = n + m <span class="comment">// 修正最終數組長度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從第18行可以得知為甚麼Obj一定要有length，再來第20到22行就能知道他push的觀點全是在length上，也就是說在obj對象最該觀察的不是其他元素而是length!</p><ol start="2"><li>原題目: </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"d"</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.push(<span class="string">"f"</span>)</span><br><span class="line">obj.push(<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><p><img src="/images/JS01/5.jpeg" alt=""></p><p>到這邊就能很明瞭，為甚麼 3會變f ，4會變 g</p><h3 id="關鍵代碼"><a href="#關鍵代碼" class="headerlink" title="關鍵代碼"></a>關鍵代碼</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">  <span class="keyword">this</span>[i + n] = %_Arauments(i)  <span class="comment">// 複製給原數組</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以想一下i = 0 的情況下會發生甚麼事，是不是this[0 + n]會被push的第一個元素取代，那這裡他的n代表的不就是Obj的 length，那就表示說Obj [3] 會被 f 取代，並且length變4 ，然後Obj[4]再被 g取代，length變5!!這就是這題的實現原理。</p><h3 id="感謝觀看-歡迎分享"><a href="#感謝觀看-歡迎分享" class="headerlink" title="感謝觀看~歡迎分享"></a><strong>感謝觀看<del>~</del>歡迎分享</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript之類數組完全攻略&quot;&gt;&lt;a href=&quot;#JavaScript之類數組完全攻略&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之類數組完全攻略&quot;&gt;&lt;/a&gt;JavaScript之類數組完全攻略&lt;/h2&gt;&lt;p&gt;今天幫大家整理偽數組的概念，我們先來從題目開始分析&lt;/p&gt;
&lt;p&gt;先來打造一個很酷的對象如下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;length&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;push&#39;&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;這時候來打印obj看會長怎樣&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://s95050937.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
