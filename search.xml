<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP代理</title>
      <link href="/2020/07/30/HTTP-post05/"/>
      <url>/2020/07/30/HTTP-post05/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h1><p>像是中間人的概念，對待裡來說既可以當服務端也可以當客戶端</p><h2 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h2><p><img src="/images/HTTP05/1.png" alt=""></p><a id="more"></a><h2 id="為何需要代理"><a href="#為何需要代理" class="headerlink" title="為何需要代理"></a>為何需要代理</h2><h3 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1. 抓包"></a>1. 抓包</h3><p>能更好分析請求與安全測試</p><h3 id="2-FQ"><a href="#2-FQ" class="headerlink" title="2. FQ"></a>2. FQ</h3><p>俗稱的翻牆</p><p><img src="/images/HTTP05/2.png" alt=""></p><h3 id="3-匿名訪問"><a href="#3-匿名訪問" class="headerlink" title="3. 匿名訪問"></a>3. 匿名訪問</h3><p>刪除客戶端HTTP報文中的私人資料，比方說Cookie或是IP地址，</p><h3 id="4-過濾器"><a href="#4-過濾器" class="headerlink" title="4. 過濾器"></a>4. 過濾器</h3><p>比方說不希望孩童從網路上看到非該年齡層的內容，因此可以透過代理過慮服務端回傳的內容</p><p><img src="/images/HTTP05/3.png" alt=""></p><h2 id="補充-網關"><a href="#補充-網關" class="headerlink" title="補充(網關)"></a>補充(網關)</h2><p>又稱作協議轉換器，為資源與應用程序的黏合器</p><h3 id="示意圖-1"><a href="#示意圖-1" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP05/4.png" alt=""></p><h3 id="講解"><a href="#講解" class="headerlink" title="講解"></a>講解</h3><p>從上圖可以發現和代理很類似，最關鍵的一點就是我們可以透過網關轉換協議，比方說上圖客戶端向網關發起HTTP協議，而後經過網觀象服務器端發起POP。</p><h3 id="分類"><a href="#分類" class="headerlink" title="分類"></a>分類</h3><p>Web在一端使用HTTP，另一端採用另一種協議可以這樣標示</p><ol><li><p>(/HTTP) 客戶端網關: 與客戶端採用其他協議，與服務端採用HTTP</p><p>記憶點: 叫客戶端網關可想像成他是幫客戶端轉換成HTTP協議的方式</p></li><li><p>(HTTP/) 服務端網關: 與服務端端採用其他協議，與客戶端採用HTTP</p><p>記憶點: 與客戶端相反</p></li></ol><h3 id="常見網關"><a href="#常見網關" class="headerlink" title="常見網關"></a>常見網關</h3><ol><li><p>(HTTP/ *) 服務器端Web網關</p></li><li><p>(HTTP/HTTPS) 服務器端安全網關</p><p> (將客戶端傳來的HTTP協議加密成HTTPS)</p></li><li><p>(HTTPS/HTTP) 客戶端安全網關 </p></li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS靜態與動態作用域</title>
      <link href="/2020/07/29/JS-post02/"/>
      <url>/2020/07/29/JS-post02/</url>
      
        <content type="html"><![CDATA[<h2 id="JS靜態與動態作用域"><a href="#JS靜態與動態作用域" class="headerlink" title="JS靜態與動態作用域"></a>JS靜態與動態作用域</h2><p>JavaScript使用的是靜態作用域，非動態這件事要先提前知道</p><h3 id="靜態作用域"><a href="#靜態作用域" class="headerlink" title="靜態作用域"></a>靜態作用域</h3><ol><li><p>懶人包 : </p><blockquote><p>會主動去尋找函數與變量定義時的狀況</p></blockquote></li><li><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'靜態作用域'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'動態作用域'</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// '靜態作用域'</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>分析 :</p><p>如果沒有作用域鏈的概念可以參考下面思維</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 前面都很正常的順順執行下來直到bar()</span><br><span class="line"><span class="number">2.</span> 當執行bar時候，會從全局作用域(因為bar執行的地方在全局作用域)裡面尋找bar聲明的地方</span><br><span class="line"><span class="number">3.</span> 進到bar函數作用域裡面(壓棧) <span class="comment">// 所在第六行</span></span><br><span class="line"><span class="number">4.</span> 在bar函數作用域裡面執行foo()，但在該函數作用域裡面沒有聲明foo，因此跑到上一層尋找，就是全局作用域</span><br><span class="line"><span class="number">5.</span> 找到foo聲明的地方，並進入foo作用域裡面</span><br><span class="line"><span class="number">5.</span> 試圖打印出a <span class="comment">// 此時所在是第四行</span></span><br><span class="line"><span class="number">6.</span> 因為foo作用域裡面沒有聲明變量a，因此又跑到全局作用域</span><br><span class="line"><span class="number">7.</span> 找到a(靜態作用域)並打印出來</span><br></pre></td></tr></table></figure></li></ol><h3 id="動態作用域"><a href="#動態作用域" class="headerlink" title="動態作用域"></a>動態作用域</h3><ol><li><p>懶人包: </p><blockquote><p>會到執行時的環境尋找</p></blockquote></li><li><p>例子(跟靜態相同): </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'靜態作用域'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'動態作用域'</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// '動態作用域'</span></span><br></pre></td></tr></table></figure><p>分析: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">前面五點都一模一樣直到第六點</span><br><span class="line"><span class="number">1.</span> 前面都很正常的順順執行下來直到bar()</span><br><span class="line"><span class="number">2.</span> 當執行bar時候，會從全局作用域(因為bar執行的地方在全局作用域)裡面尋找bar聲明的地方</span><br><span class="line"><span class="number">3.</span> 進到bar函數作用域裡面(壓棧) <span class="comment">// 所在第六行</span></span><br><span class="line"><span class="number">4.</span> 在bar函數作用域裡面執行foo()，但在該函數作用域裡面沒有聲明foo，因此跑到上一層尋找，就是全局作用域</span><br><span class="line"><span class="number">5.</span> 找到foo聲明的地方，並進入foo作用域裡面</span><br><span class="line"><span class="number">5.</span> 試圖打印出a </span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 這時候找不到a並不會跑到上一層作用域鏈查找，而是回到執行時的環境也就是第八行所在的作用域查找</span><br><span class="line"><span class="number">7.</span> 這時候就會發現a是動態作用域並打印出</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的長連接與短連接</title>
      <link href="/2020/07/29/HTTP-post04/"/>
      <url>/2020/07/29/HTTP-post04/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的長連接與短連接"><a href="#HTTP的長連接與短連接" class="headerlink" title="HTTP的長連接與短連接"></a>HTTP的長連接與短連接</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>其實HTTP的長連接與短連接是在講TCP的長連接與短連接</p></blockquote><h2 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h2><p>打開台大的網站按F12，可以發現有一個Connection: Keep-Alive，那個就是長連結</p><p><img src="/images/HTTP04/1.png" alt=""></p><a id="more"></a><h2 id="差別"><a href="#差別" class="headerlink" title="差別"></a>差別</h2><p>短連接 </p><blockquote><p>建立連結 =&gt; 數據傳輸 =&gt; 關閉連結 =&gt; ….  =&gt; 建立連結 =&gt; 數據傳輸 =&gt; 關閉連結 =&gt;</p></blockquote><p>長連結(可以省去TCP連接與關閉的時間)</p><p>​    通常關閉連結會是服務端，因為隨著連結的客戶端越來越多，服務端會有撐不下去的時候</p><blockquote><p>建立連結 =&gt; 數據傳輸 =&gt; …. (保持連結) …. =&gt;  數據傳輸 =&gt; 關閉連結</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>具體誰好誰壞沒有一定，當然還是要視情況而定</p><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP之身分認證</title>
      <link href="/2020/07/29/HTTP-post03/"/>
      <url>/2020/07/29/HTTP-post03/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP之身分認證"><a href="#HTTP之身分認證" class="headerlink" title="HTTP之身分認證"></a>HTTP之身分認證</h1><p>有以下四種認證</p><ol><li>BASIC認證 (基本認證)</li><li>DIGEST認證 (摘要認證)</li><li>SSL客戶端認證</li><li>FormBase認證 (基於表單驗證)</li></ol><a id="more"></a><h2 id="BASIC認證"><a href="#BASIC認證" class="headerlink" title="BASIC認證"></a>BASIC認證</h2><p>HTTP 1.0 即存在</p><h3 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP03/1.png" alt=""></p><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>因為沒有加密，如果不小心被其他有心人士獲取，則帳號密碼經Base64解碼即獲得相當不安全，因此又有了DIGEST認證</p><h2 id="DIGEST-認證"><a href="#DIGEST-認證" class="headerlink" title="DIGEST 認證"></a>DIGEST 認證</h2><p>HTTP1.1存在</p><h3 id="示意圖-1"><a href="#示意圖-1" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP03/2.png" alt=""></p><p>這種方法雖然解決加密，但沒有解決用戶可能被冒充的問題(只要用戶名與密碼正確就認為你是本人)</p><h2 id="SSL-客戶端認證"><a href="#SSL-客戶端認證" class="headerlink" title="SSL 客戶端認證"></a>SSL 客戶端認證</h2><p>藉由HTTPS 客戶端憑證，服務器可確認訪問是否來自已登入瘩客戶端</p><h2 id="基於表單驗證明"><a href="#基於表單驗證明" class="headerlink" title="基於表單驗證明"></a>基於表單驗證明</h2><ol><li>不是在HTTP協議定義的</li><li>使用web各自實現表單認證方式</li><li>通過cookie與session</li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP協議編碼與解碼</title>
      <link href="/2020/07/29/HTTP-post02/"/>
      <url>/2020/07/29/HTTP-post02/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP協議編碼與解碼"><a href="#HTTP協議編碼與解碼" class="headerlink" title="HTTP協議編碼與解碼"></a>HTTP協議編碼與解碼</h1><p>在講解編碼之前我們率先了解一下甚麼是碼</p><h2 id="字符集與編碼"><a href="#字符集與編碼" class="headerlink" title="字符集與編碼"></a>字符集與編碼</h2><h3 id="計算機如何顯示文字"><a href="#計算機如何顯示文字" class="headerlink" title="計算機如何顯示文字"></a>計算機如何顯示文字</h3><p>有些人應該已經知道計算機系統是利用二進制保存操作，那我們就要思考如何把這種二進制系統轉換成我們的畫面</p><h3 id="示意圖"><a href="#示意圖" class="headerlink" title="示意圖"></a>示意圖</h3><p><img src="/images/HTTP02/1.png" alt=""></p><a id="more"></a><p>現在想像計算機是一個人，如果我們今天想要找水壺的英文，那我們是不是會打開字典開始尋找。對計算機來說字符集就是他看得懂的語言，而字庫表就是他查找水壺這個英文的字典</p><ol><li>字符集: 某一個電腦看得懂的二進制代碼(地址的集合)</li><li>字庫表: 儲存所有二進制代碼的具體內容(那一本字典)</li><li>編碼方式: 算法，因為二進制樹又臭又長很難搞</li></ol><h3 id="具體流程"><a href="#具體流程" class="headerlink" title="具體流程"></a>具體流程</h3><blockquote><p>一個二進制樹經過一個編碼方式得到字符集對應的地址，在字庫表找到對應的字符，最後顯示給用戶</p></blockquote><h2 id="常見編碼規範"><a href="#常見編碼規範" class="headerlink" title="常見編碼規範"></a>常見編碼規範</h2><p><img src="/images/HTTP02/2.png" alt=""></p><h2 id="為何會亂碼"><a href="#為何會亂碼" class="headerlink" title="為何會亂碼"></a>為何會亂碼</h2><p>不管是在編碼或者解碼的過程中，假如我們解析的過程沒有找到一一對應的字符集或者字符表，就會產生亂碼。比方說ASCII不支持中文，如果我們在解碼過程發現中文字就會產生亂碼。</p><h2 id="URL的編碼以及解碼"><a href="#URL的編碼以及解碼" class="headerlink" title="URL的編碼以及解碼"></a>URL的編碼以及解碼</h2><ol><li><p>採用ASCII字符集進行編碼，假如有非ASCII的字符要對其進行編碼</p></li><li><p>URL 有一些保留字(比如&amp;)，如果要在URL使用也要進行編碼</p></li></ol><h3 id="百分號編碼規範"><a href="#百分號編碼規範" class="headerlink" title="百分號編碼規範"></a>百分號編碼規範</h3><ol><li>屬於ASCII字符集的非保留字不做編碼</li><li>屬於ASCII字符集的保留字取得ASCII的內碼，再加上%前綴後進行編碼</li><li>非ASCII則取Unicode內碼，加上%前綴後進行編碼</li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP_詳解Cookie與Session</title>
      <link href="/2020/07/28/HTTP-post01/"/>
      <url>/2020/07/28/HTTP-post01/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-狀態管理-cookie與session"><a href="#HTTP-狀態管理-cookie與session" class="headerlink" title="HTTP 狀態管理: cookie與session"></a>HTTP 狀態管理: cookie與session</h1><p>大家先來想想一個例子，如果我今天要開一間咖啡館，然後有一個滿10點送50元飲料，我該怎麼去紀錄?</p><ol><li>集點蓋章</li><li>老闆自備簽名章</li></ol><p>一般人可能會講上面那兩點，但事實上上面那兩個方法有點問題，我們無法知道雙方會部會造假，因此得出了第三個方法，你有自己的會員蓋章，老闆也準備自己的系統紀錄，假如要兌換，就核對一下即可頒發。cookie與session就是為了解決第三個辦法的蓋章卡以及老闆的系統。</p><a id="more"></a><h2 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h2><h3 id="是甚麼"><a href="#是甚麼" class="headerlink" title="是甚麼"></a>是甚麼</h3><p>一小段文本訊息，客戶端請求服務器，服務器就頒發一個cookie給客戶端瀏覽器(蓋章卡) ， 客戶端瀏覽器就把它保留下來，假設下次再請求，瀏覽器會把cookie跟網址提交給服務器，讓服務器辨別用戶狀態。</p><h3 id="流程圖"><a href="#流程圖" class="headerlink" title="流程圖"></a>流程圖</h3><p><img src="/images/HTTP01/1.png" alt=""></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/images/HTTP01/2.png" alt=""></p><h2 id="如何獲取"><a href="#如何獲取" class="headerlink" title="如何獲取"></a>如何獲取</h2><blockquote><p>可以在瀏覽器打網址的地方輸入下面這行javascript:alert(document.cookie)</p></blockquote><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="是甚麼-1"><a href="#是甚麼-1" class="headerlink" title="是甚麼"></a>是甚麼</h3><blockquote><p>服務器端紀錄用戶訊息的機制(老闆的紀錄器)</p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/images/HTTP01/3.png" alt=""></p><h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>基本上cookie有效時間會非常非常久，而session因為視服務端，會有大量的session紀錄，可能會內存溢出，因此會有失效，又分成下面幾種</p><ol><li>自動失效: session超時</li><li>主動失效: 調用HttpSession.invalidate( ) </li><li>服務器進程被停止</li></ol><h2 id="兩者比較"><a href="#兩者比較" class="headerlink" title="兩者比較"></a>兩者比較</h2><ol><li><p>存放位置不同 (一個存在服務器，一個存在客戶端)</p></li><li><p>安全性不同 </p><p>cookie可能會被其他程式窺視，因此cookie盡量不要放帳號密碼</p></li><li><p>有效期不同 (session會自動清理，cookie基本上不會消失因為通常沒有像session有內存溢出的問題)</p></li></ol><blockquote><p>以上為<a href="https://coding.imooc.com/class/395.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/395.html#Anchor</a> 整理下來的筆記</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript偽數組</title>
      <link href="/2020/07/27/JS_post01/"/>
      <url>/2020/07/27/JS_post01/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript之類數組完全攻略"><a href="#JavaScript之類數組完全攻略" class="headerlink" title="JavaScript之類數組完全攻略"></a>JavaScript之類數組完全攻略</h2><p>今天幫大家整理偽數組的概念，我們先來從題目開始分析</p><p>先來打造一個很酷的對象如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'length'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候來打印obj看會長怎樣</p><a id="more"></a><p><img src="/images/JS01/1.jpeg" alt=""></p><p>乍看之下他還只是一個平常的對象，但其實這個對象這時候已經變成一個類數組了! 我們來對他做以下操作可以更明白</p><p><img src="/images/JS01/2.jpeg" alt=""></p><p>可以發現到這時候他多了一個 3: “d” ，對象原本是不能這樣做的，但是在這邊卻可以實現，因此才對他取名叫做類數組。</p><h3 id="如何打造一個類數組對象"><a href="#如何打造一個類數組對象" class="headerlink" title="如何打造一個類數組對象:"></a>如何打造一個類數組對象:</h3><p>要打造出一個類數組有要打造出一個類數組有幾個條件</p><ol><li>他必須要是一個對象</li><li>屬性要為索引(數字)值</li><li>一定要有length存在</li><li>最好可以加push</li><li>附註: 如果想讓它變得更像數組可以加上splice，如下圖</li></ol><p><img src="/images/JS01/3.jpeg" alt=""></p><h3 id="出問題考考大家"><a href="#出問題考考大家" class="headerlink" title="出問題考考大家"></a>出問題考考大家</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"d"</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.push(<span class="string">"f"</span>)</span><br><span class="line">obj.push(<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p><img src="/images/JS01/4.jpeg" alt=""></p><p>3的 “d” 居然被 “f” 覆蓋掉了，而且多了一個4 : “g” ，我們來講解一下實現原理!!</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><ol><li>在講這個之前我們要先觀察Array.prototype.push的實現方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是push的偽代碼</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = TO_UNIT32(<span class="keyword">this</span>.length) <span class="comment">// 被push的數組長度(類數組採用的length就是這個)</span></span><br><span class="line">  <span class="keyword">var</span> m = %_AraumentsLength() <span class="comment">// push的總長度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i + n] = %_Arauments(i)  <span class="comment">// 複製給原數組</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">this</span>.length = n + m <span class="comment">// 修正最終數組長度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從第18行可以得知為甚麼Obj一定要有length，再來第20到22行就能知道他push的觀點全是在length上，也就是說在obj對象最該觀察的不是其他元素而是length!</p><ol start="2"><li>原題目: </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"d"</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.push(<span class="string">"f"</span>)</span><br><span class="line">obj.push(<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><p><img src="/images/JS01/5.jpeg" alt=""></p><p>到這邊就能很明瞭，為甚麼 3會變f ，4會變 g</p><h3 id="關鍵代碼"><a href="#關鍵代碼" class="headerlink" title="關鍵代碼"></a>關鍵代碼</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">  <span class="keyword">this</span>[i + n] = %_Arauments(i)  <span class="comment">// 複製給原數組</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以想一下i = 0 的情況下會發生甚麼事，是不是this[0 + n]會被push的第一個元素取代，那這裡他的n代表的不就是Obj的 length，那就表示說Obj [3] 會被 f 取代，並且length變4 ，然後Obj[4]再被 g取代，length變5!!這就是這題的實現原理。</p><h3 id="感謝觀看-歡迎分享"><a href="#感謝觀看-歡迎分享" class="headerlink" title="感謝觀看~歡迎分享"></a><strong>感謝觀看<del>~</del>歡迎分享</strong></h3>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
